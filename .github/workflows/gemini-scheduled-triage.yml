name: "\U0001F4CB Gemini Scheduled Issue Triage"
true:
  schedule:
  - cron: 0 * * * *
  push:
    branches:
    - main
    - release/**/*
    paths:
    - .github/workflows/gemini-scheduled-triage.yml
  workflow_dispatch: null
concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true
defaults:
  run:
    shell: bash
jobs:
  triage:
    runs-on: ubuntu-slim
    timeout-minutes: 7
    permissions:
      contents: read
      issues: read
      pull-requests: read
    outputs:
      available_labels: ${{ steps.get_labels.outputs.available_labels }}
      issues_to_triage: ${{ steps.find_issues.outputs.issues_to_triage }}
    steps:
    - name: Get repository labels
      id: get_labels
      uses: actions/github-script@v8
      with:
        script: "const { data: labels } = await github.rest.issues.listLabelsForRepo({\n\
          \  owner: context.repo.owner,\n  repo: context.repo.repo,\n});\n\nif (!labels\
          \ || labels.length === 0) {\n  core.setFailed('There are no issue labels\
          \ in this repository.')\n}\n\nconst labelNames = labels.map(label => label.name).sort();\n\
          core.setOutput('available_labels', labelNames.join(','));\ncore.info(`Found\
          \ ${labelNames.length} labels: ${labelNames.join(', ')}`);\nreturn labelNames;"
    - name: Find untriaged issues
      id: find_issues
      env:
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_TOKEN: ${{ github.token }}
      run: "echo '\U0001F50D Finding unlabeled issues and issues marked for triage...'\n\
        ISSUES=\"$(gh issue list \\\n  --state 'open' \\\n  --search 'no:label' \\\
        \n  --json number,title,body \\\n  --limit '100' \\\n  --repo \"${GITHUB_REPOSITORY}\"\
        \n)\"\n\necho '\U0001F4DD Setting output for GitHub Actions...'\nEOF=$(dd\
        \ if=/dev/urandom bs=15 count=1 status=none | base64)\necho \"issues_to_triage<<$EOF\"\
        \ >> \"$GITHUB_OUTPUT\"\necho \"$ISSUES\" >> \"$GITHUB_OUTPUT\"\necho \"$EOF\"\
        \ >> \"$GITHUB_OUTPUT\"\n\nISSUE_COUNT=\"$(echo \"${ISSUES}\" | jq 'length')\"\
        \necho \"\u2705 Found ${ISSUE_COUNT} issue(s) to triage! \U0001F3AF\""
  call_triage:
    needs: triage
    if: needs.triage.outputs.issues_to_triage != '[]' && needs.triage.outputs.issues_to_triage
      != ''
    uses: ./.github/workflows/gemini-triage-bulk.yml
    permissions:
      contents: read
      issues: write
      pull-requests: read
    with:
      additional_context: Scheduled triage run
      issues_to_triage: ${{ needs.triage.outputs.issues_to_triage }}
      language: ja
      gemini_model: gemini-2.5-flash
    secrets: inherit
    timeout-minutes: 30
  label:
    runs-on: ubuntu-latest
    needs:
    - call_triage
    permissions:
      contents: read
      issues: write
      pull-requests: write
    steps:
    - name: Apply labels
      env:
        AVAILABLE_LABELS: ${{ needs.call_triage.outputs.available_labels }}
        TRIAGED_ISSUES: ${{ needs.call_triage.outputs.triaged_issues }}
      uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
      with:
        github-token: ${{ github.token }}
        script: "// Parse the available labels\nconst availableLabels = (process.env.AVAILABLE_LABELS\
          \ || '').split(',')\n  .map((label) => label.trim())\n  .sort()\n\n// Parse\
          \ out the triaged issues\nlet triagedIssues = [];\ntry {\n  const triagedData\
          \ = process.env.TRIAGED_ISSUES || '[]';\n  triagedIssues = JSON.parse(triagedData);\n\
          \  if (!Array.isArray(triagedIssues)) {\n    triagedIssues = [];\n  }\n\
          } catch (error) {\n  core.warning(`Error parsing triaged issues: ${error.message}`);\n\
          \  triagedIssues = [];\n}\ntriagedIssues = triagedIssues.sort((a, b) =>\
          \ a.issue_number - b.issue_number);\n\ncore.info(`Triaged issues: ${JSON.stringify(triagedIssues)}`);\n\
          \n// Iterate over each label\nfor (const issue of triagedIssues) {\n  if\
          \ (!issue) {\n    core.info(`Skipping empty issue: ${JSON.stringify(issue)}`);\n\
          \    continue;\n  }\n\n  const issueNumber = issue.issue_number;\n  if (!issueNumber)\
          \ {\n    core.info(`Skipping issue with no data: ${JSON.stringify(issue)}`);\n\
          \    continue;\n  }\n\n  // Extract and reject invalid labels - we do this\
          \ just in case\n  // someone was able to prompt inject malicious labels.\n\
          \  let labelsToSet = (issue.labels_to_set || [])\n    .map((label) => label.trim())\n\
          \    .filter((label) => availableLabels.includes(label))\n    .sort()\n\n\
          \  core.info(`Identified labels to set: ${JSON.stringify(labelsToSet)}`);\n\
          \n  if (labelsToSet.length === 0) {\n    core.info(`Skipping issue #${issueNumber}\
          \ - no labels to set.`)\n    continue;\n  }\n\n  core.info(`Setting labels\
          \ on issue #${issueNumber} to ${labelsToSet.join(', ')} (${issue.explanation\
          \ || 'no explanation'})`)\n\n  await github.rest.issues.setLabels({\n  \
          \  owner: context.repo.owner,\n    repo: context.repo.repo,\n    issue_number:\
          \ issueNumber,\n    labels: labelsToSet,\n  });\n}"
    timeout-minutes: 30
permissions:
  contents: read
  issues: read
  pull-requests: read
