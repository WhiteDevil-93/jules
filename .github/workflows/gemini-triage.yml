name: "\U0001F500 Gemini Triage"
true:
  workflow_call:
    inputs:
      additional_context:
        type: string
        description: Any additional context from the request
        required: false
      language:
        type: string
        description: "Response language (default: 'ja' \u2014 JP)."
        default: ja
      gcp_location:
        type: string
        description: GCP location override
        required: false
        default: ''
      gcp_project_id:
        type: string
        description: GCP project id override
        required: false
        default: ''
      gcp_service_account:
        type: string
        description: GCP service account override
        required: false
        default: ''
      gcp_workload_identity_provider:
        type: string
        description: GCP WIF provider override
        required: false
        default: ''
      gemini_cli_version:
        type: string
        description: Gemini CLI version override
        required: false
        default: ''
      gemini_debug:
        type: string
        description: Gemini debug override
        required: false
        default: 'false'
      gemini_model:
        type: string
        description: Gemini model override
        required: false
        default: ''
      use_gemini_code_assist:
        type: string
        description: Whether to use Gemini Code Assist
        required: false
        default: 'false'
      use_vertex_ai:
        type: string
        description: Whether to use Vertex AI
        required: false
        default: 'false'
    secrets:
      GEMINI_API_KEY:
        required: false
concurrency:
  group: ${{ github.workflow }}-triage-${{ github.event_name }}-${{ github.event.pull_request.number
    || github.event.issue.number }}
  cancel-in-progress: true
defaults:
  run:
    shell: bash
jobs:
  triage:
    runs-on: ubuntu-slim
    timeout-minutes: 7
    outputs:
      available_labels: ${{ steps.get_labels.outputs.available_labels }}
      selected_labels: ${{ steps.collect_selected.outputs.selected_labels }}
      triaged_issues: ${{ steps.collect_selected.outputs.triaged_issues }}
    permissions:
      contents: read
      issues: read
      pull-requests: read
    steps:
    - name: Get repository labels
      id: get_labels
      uses: actions/github-script@v8
      with:
        script: "const { data: labels } = await github.rest.issues.listLabelsForRepo({\n\
          \  owner: context.repo.owner,\n  repo: context.repo.repo,\n});\n\nif (!labels\
          \ || labels.length === 0) {\n  core.setFailed('There are no issue labels\
          \ in this repository.')\n}\n\nconst labelNames = labels.map(label => label.name).sort();\n\
          core.setOutput('available_labels', labelNames.join(','));\ncore.info(`Found\
          \ ${labelNames.length} labels: ${labelNames.join(', ')}`);\nreturn labelNames;"
    - name: Check GEMINI_API_KEY presence (debug-only)
      if: ${{ fromJSON(vars.DEBUG || vars.ACTIONS_STEP_DEBUG || false) }}
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      run: "if [ -z \"${GEMINI_API_KEY}\" ]; then\n  echo \"GEMINI_API_KEY_PRESENT=false\"\
        \nelse\n  echo \"GEMINI_API_KEY_PRESENT=true\"\nfi"
    - name: Run Gemini issue analysis
      id: gemini_analysis
      if: ${{ steps.get_labels.outputs.available_labels != '' && (inputs.issues_to_triage
        == '' || inputs.issues_to_triage == null) }}
      uses: google-github-actions/run-gemini-cli@v0
      env:
        GITHUB_TOKEN: ''
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        ISSUE_TITLE: ${{ github.event.issue.title }}
        ISSUE_BODY: ${{ github.event.issue.body }}
        AVAILABLE_LABELS: ${{ steps.get_labels.outputs.available_labels }}
      with:
        gcp_location: ${{ inputs.gcp_location || vars.GOOGLE_CLOUD_LOCATION || ''
          }}
        gcp_project_id: ${{ inputs.gcp_project_id || vars.GOOGLE_CLOUD_PROJECT ||
          '' }}
        gcp_service_account: ${{ inputs.gcp_service_account || vars.SERVICE_ACCOUNT_EMAIL
          || '' }}
        gcp_workload_identity_provider: ${{ inputs.gcp_workload_identity_provider
          || vars.GCP_WIF_PROVIDER || '' }}
        gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
        gemini_cli_version: ${{ inputs.gemini_cli_version || vars.GEMINI_CLI_VERSION
          || '' }}
        gemini_debug: ${{ fromJSON(inputs.gemini_debug || vars.DEBUG || vars.ACTIONS_STEP_DEBUG
          || 'false') }}
        gemini_model: ${{ inputs.gemini_model || vars.GEMINI_MODEL || '' }}
        use_gemini_code_assist: ${{ inputs.use_gemini_code_assist || vars.GOOGLE_GENAI_USE_GCA
          || '' }}
        use_vertex_ai: ${{ inputs.use_vertex_ai || vars.GOOGLE_GENAI_USE_VERTEXAI
          || '' }}
        settings: "{\n  \"model\": {\n    \"maxSessionTurns\": 25\n  },\n  \"telemetry\"\
          : {\n    \"enabled\": ${{ vars.GOOGLE_CLOUD_PROJECT != '' }},\n    \"target\"\
          : \"gcp\"\n  },\n  \"tools\": {\n    \"core\": [\n      \"run_shell_command\"\
          \n    ]\n  }\n}"
        prompt: "\u51FA\u529B\u306F\u5FC5\u305A\u65E5\u672C\u8A9E\u3067\u884C\u3063\
          \u3066\u304F\u3060\u3055\u3044\u3002\n\u5FDC\u7B54\u8A00\u8A9E: ${{ inputs.language\
          \ }}\n## Role\n\nYou are an issue triage assistant. Analyze the current\
          \ GitHub issue and identify the most appropriate existing labels.\n\n##\
          \ Guidelines\n\n- Only use labels that are from the list of available labels.\n\
          - You can choose multiple labels to apply.\n- When generating shell commands,\
          \ you **MUST NOT** use command substitution with `$(...)`, `<(...)`, or\
          \ `>(...)`. This is a security measure to prevent unintended command execution.\n\
          \n## Input Data\n\n**Available Labels** (comma-separated):\n```\n${{ env.AVAILABLE_LABELS\
          \ }}\n```\n\n**Issue Title**:\n```\n${{ env.ISSUE_TITLE }}\n```\n\n**Issue\
          \ Body**:\n```\n${{ env.ISSUE_BODY }}\n```\n\n**Output File Path**:\n```\n\
          /tmp/runner/env\n```\n\n## Steps\n\n1. Review the issue title, issue body,\
          \ and available labels provided above.\n\n2. Based on the issue title and\
          \ issue body, classify the issue and choose all appropriate labels from\
          \ the list of available labels.\n\n4. Convert the list of appropriate labels\
          \ into a comma-separated list (CSV). If there are no appropriate labels,\
          \ use the empty string.\n\n5. Use the run_shell_command tool to execute\
          \ the echo command and append the CSV labels to the output file path provided\
          \ above:\n\n    ```\n    run_shell_command(echo \"SELECTED_LABELS=[APPROPRIATE_LABELS_AS_CSV]\"\
          \ >> \"/tmp/runner/env\")\n    ```\n\n    for example:\n\n    ```\n    run_shell_command(echo\
          \ \"SELECTED_LABELS=bug,enhancement\" >> \"/tmp/runner/env\")\n    ```"
    - name: Collect outputs
      id: collect_selected
      uses: actions/github-script@v8
      with:
        script: "const fs = require('fs');\nconst path = '/tmp/runner/env';\nlet selectedLabels\
          \ = '';\nlet triagedIssues = '';\n\ntry {\n  if (fs.existsSync(path)) {\n\
          \    const content = fs.readFileSync(path, 'utf8');\n    const lines = content.split('\\\
          n');\n    for (const line of lines) {\n      if (line.startsWith('SELECTED_LABELS='))\
          \ {\n        selectedLabels = line.substring('SELECTED_LABELS='.length);\n\
          \      } else if (line.startsWith('TRIAGED_ISSUES=')) {\n        triagedIssues\
          \ = line.substring('TRIAGED_ISSUES='.length);\n      }\n    }\n  }\n} catch\
          \ (error) {\n  core.warning(`Error reading output file: ${error.message}`);\n\
          }\n\ncore.setOutput('selected_labels', selectedLabels);\ncore.setOutput('triaged_issues',\
          \ triagedIssues);"
  label:
    runs-on: ubuntu-slim
    needs:
    - triage
    permissions:
      contents: read
      issues: write
      pull-requests: write
    steps:
    - name: Apply labels
      env:
        ISSUE_NUMBER: ${{ github.event.issue.number }}
        AVAILABLE_LABELS: ${{ needs.triage.outputs.available_labels }}
        SELECTED_LABELS: ${{ needs.triage.outputs.selected_labels }}
      uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
      with:
        github-token: ${{ github.token }}
        script: "// Parse the available labels\nconst availableLabels = (process.env.AVAILABLE_LABELS\
          \ || '').split(',')\n  .map((label) => label.trim())\n  .sort()\n\n// Parse\
          \ the label as a CSV, reject invalid ones - we do this just\n// in case\
          \ someone was able to prompt inject malicious labels.\nconst selectedLabels\
          \ = (process.env.SELECTED_LABELS || '').split(',')\n  .map((label) => label.trim())\n\
          \  .filter((label) => availableLabels.includes(label))\n  .sort()\n\n//\
          \ Set the labels\nconst issueNumber = process.env.ISSUE_NUMBER;\nif (selectedLabels\
          \ && selectedLabels.length > 0) {\n  await github.rest.issues.setLabels({\n\
          \    owner: context.repo.owner,\n    repo: context.repo.repo,\n    issue_number:\
          \ issueNumber,\n    labels: selectedLabels,\n  });\n  core.info(`Successfully\
          \ set labels: ${selectedLabels.join(',')}`);\n} else {\n  core.info(`Failed\
          \ to determine labels to set. There may not be enough information in the\
          \ issue or pull request.`)\n}"
    timeout-minutes: 30
permissions:
  contents: read
  issues: read
  pull-requests: read
